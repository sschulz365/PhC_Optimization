#Sean Billings, 2015
import random
import numpy
import subprocess
import constraints
from experiment import Experiment
from objectiveFunctions import WeightedSumObjectiveFunction, IdealDifferentialObjectiveFunction
from waveGuideMPBOptimizer import differentialEvolution, createPopulation, gradientDescentAlgorithm
import utilities
import math

paramMap = {}
paramMap["s1"] = 0 # First row vertical shift
paramMap["s2"] = 0 # Second row vertical shift
paramMap["s3"] = 0 # Third row vertical shift
paramMap["p1"] = 0 # First row horizontal shift
paramMap["p2"] = 0 # Second row horizontal shift
paramMap["p3"] = 0 # Third row horizontal shift
paramMap["r0"] = 0.3 # Default air-hole radius
paramMap["r1"] = 0.3 # Default first row radius
paramMap["r2"] = 0.3 # Default second row radius
paramMap["r3"] = 0.3 # Default third row radius

# absolute path to the mpb executable
mpb = "/Users/sean/documents/mpb-1.5/mpb/mpb"

# absolute path to the input ctl
inputFile = "/Users/sean/documents/W1_2D_v03.ctl.txt"

# absolute path to the output ctl
outputFile = "/Users/sean/documents/optimizerTestFile.txt"


# we define a general experiment object
# that we reuse whenever we need to make a command-line mpb call
# see experiment.py for functionality
experiment = Experiment(mpb, inputFile, outputFile)
# ex.setParams(paramVector)
experiment.setCalculationType('4') # accepts an int from 0 to 5
experiment.setBand(23)


# see constraints.py
constraintFunctions = [constraints.latticeConstraintsLD]

max_generation = 15 # number of iterations of the DE alg
population_size = 20 # number of solutions to consider in DE
random_update = 0.2 # chance of updating vector fields in DE alg
elite_size = 10 # number of solutions to store in DE, and use for GD
band = 23 # band of interest for MPB computations

# specify the weights for the IdealDifferentialObjectiveFunction

w1 = 0 #0.01 # bandwidth weight
w2 = 30 #100 # group index weight
w3 = 0 # average loss weight
w4 = 0 # BGP weight
w5 = 30 #0.002 # loss at ngo (group index) weight
w6 = 0

# these wights are use in the Objective Function to score mpb results
weights = [ w1, w2, w3, w4, w5, w6]


ideal_group_index = 30 #self.ideal_solution[0]
ideal_bandwidth = 0.007 #self.ideal_solution[1]
ideal_loss_at_group_index = 30 #self.ideal_solution[2]
ideal_bgp = 0.3 #self.ideal_solution[3]
ideal_delay = 300 #self.ideal_solution[4]


ideal = [ideal_group_index, ideal_bandwidth, ideal_loss_at_group_index, ideal_bgp, ideal_delay]
    

#Initialize objective function
#objFunc = IdealDifferentialObjectiveFunction(weights, experiment, ideal)
objFunc = WeightedSumObjectiveFunction(weights, experiment)

# Differential Evolution section

print "Starting Differential Evolution Optimizer"
# DEsolutions is an array of solutions generated by the DE alg
DEsolutions = differentialEvolution(constraintFunctions, objFunc,
                                  max_generation, population_size, random_update,
                                  paramMap, elite_size, experiment)

print "\nDifferential Evolution solutions generated"

population = DEsolutions

# test line
#population = createPopulation(constraintFunctions, population_size, paramMap)

descent_scaler = 0.2
completion_scaler = 0.1
alpha_scaler = 0.9



# Gradient Descent Section

print "\nStarting Gradient Descent Optimizer"
# GDsolutions is an array of solutions generated by the GD algorihtms

GDsolutions = gradientDescentAlgorithm(objFunc,
                                     constraintFunctions,
                                     population, descent_scaler,
                                     completion_scaler, alpha_scaler)

population = GDsolutions


print "\nResults"

for solution in population:

    print "\nSolution: " + str(solution)
    results = objFunc.evaluate(solution)
    solution_score = results[0]
    bandwidth = results[1]
    group_index = results[2]
    avgLoss = results[3] # average loss
    bandwidth_group_index_product = results[4] #BGP
    loss_at_ng0 = results[5] # loss at group index
    print "\nScore: " + str(solution_score)
    print "\nNormalized Bandwidth: " +  str(bandwidth)
    print "\nGroup Index: " + str(group_index)
    print "\nAverage Loss: " + str(avgLoss)
    print "\nLoss at Group Index: " + str(loss_at_ng0)
    print "\nBGP: " + str(bandwidth_group_index_product)
    
    #print "\nComputing Fabrication Stability..."
    
    #laplacian = utilities.computeLaplacian(weights, weightedSumObjectiveFunction, solution, experiment)
    #fabrication_stability = 0
    #for key in laplacian.keys():
    #    fabrication_stability = fabrication_stability + laplacian[key]**2

    #fabrication_stability = math.sqrt(fabrication_stability)
    #print "\nFabrication Stability " + str(fabrication_stability)

print "\nOptimization Complete"
